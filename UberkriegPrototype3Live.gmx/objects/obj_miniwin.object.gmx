<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_miniwin_standard</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initiate

//set depth
depth = UI_DEPTH_WIN;
//stop animation
image_speed = 0;
// position variable
isLeft = true ;

//window type
miniwin_type = "standard";
miniwin_terrain = spr_miniwin_Plains;
miniwin_terrain_ownership = 0;
miniwin_unit = spr_miniwin_LightTank;
miniwin_unit_ownership = 0;

//aux display (temperary terrain and unit intel display switch)
aux_on = false;







</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Location: Left or Right
miniwinLRcheckX = 24*global.posX;
miniwinLRcheckY = 24*global.posY;

    if (view_xview - miniwinLRcheckX &gt; - 300 and view_yview - miniwinLRcheckY &lt; - 240 ){
        x =  view_xview[0] + 588;
        y =  view_yview[0] + 324;
        isLeft = false;
        }
        
    else if (view_xview - miniwinLRcheckX &lt; - 384 and view_yview - miniwinLRcheckY &lt; - 240 ){
        x =  view_xview[0] + 12;
        y =  view_yview[0] + 324;
         isLeft = true;
        }
    
    else if isLeft{
        x =  view_xview[0] + 12;
        y =  view_yview[0] + 324;
        }
    
    else{
        x =  view_xview[0] + 588;
        y =  view_yview[0] + 324;
        }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Retrieve Intel from battle curosr

//retrive terrain object index
miniwin_terrain = asset_get_index("spr_miniwin_" + string_letters(global.terrain_check.name));

// retrive terrain ownership if property
if  (object_is_ancestor(global.terrain_check.object_index,obj_property) and (global.terrain_check.isObservable or global.terrain_check.name = "HQ")  ){ 
    miniwin_terrain_ownership = global.terrain_check.ownership;
    }
else miniwin_terrain_ownership = 0;

// retrieve unit info

if (global.unit_check != 0){
    if (global.unit_check.isObservable){
        //get unit sprite index
        miniwin_unit = asset_get_index("spr_miniwin_" + string_letters(global.unit_check.name));
        
        //get unit ownership, and interpet image index
        miniwin_unit_ownership = global.unit_check.ownership - 1;
        }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Window Type change: standard, halfsize, load L or R


if ( global.unit_check = 0){
    sprite_index = asset_get_index("spr_miniwin_halfsize");
    }
    
if ( global.unit_check != 0){
     if (global.unit_check.isObservable)
        sprite_index = asset_get_index("spr_miniwin_standard");
    }
    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///aux display control

if global.ip_X_pressed{
    aux_on = true;
    depth = UI_DEPTH_CURSOR -1;
    }
if global.ip_X_released{
    aux_on = false;
    depth = UI_DEPTH_WIN;
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Image Index Controller
image_index = global.P_Turn.number - 1 ;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw calc

//current player sprite index
d_player_index = global.P_Turn.number-1;

//d_load_ax = x+172;
//d_load_ay =  y+12;


//all unit stats are on same row
d_units_y = y+26;
//HP
d_hiddenHP_x = x+78-11;
d_HP_x = x+78;
//Fuel
d_fuel_x = x+123;
//Ammo
d_ammo_x = x+142;

//Terrain data, on same row
d_terrain_y = y+74;
//cap
d_cap_x = x+139;
d_flag_x = x+144


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
/*///intel windows

if aux_on{
    //draw unit intel
    if global.unit_check!=0{
        if global.unit_check.isVisible{
            //draw base window
            draw_sprite(spr_temp_unit_summary,0,150,110);
            //draw unit states
            draw_text(150+12,110+12*1,global.unit_check.display_name);
            draw_text(150+12,110+14*2,"Ownership: P"+string(global.unit_check.ownership));
            //draw_text(150+12,110+14*3,"Charge Value: "+string(global.unit_check.charge));
            //draw_text(150+12,110+14*5,"Min Attack Range: "+string(global.unit_check.min_range));
            //draw_text(150+12,110+14*6,"Max Attack Range: "+string(global.unit_check.max_range));
            draw_text(150+12,110+14*3,"Attack Range: "+string(global.unit_check.min_range)+"~"+string(global.unit_check.max_range));
            draw_text(150+12,110+14*4,"Max Ammo/Supplies: "+string(global.unit_check.max_ammo));
            
            draw_text(150+12,110+14*5,"Base Vision: "+string(global.unit_check.vision));
            draw_text(150+12,110+14*6,"Base Radio: "+string(global.unit_check.radio));
            
            draw_text(150+12,110+14*7,"Move Type: "+global.unit_check.move_type);
            draw_text(150+12,110+14*8,"Move Range: "+string(global.unit_check.move_points));
            draw_text(150+12,110+14*9,"Max fuel: "+string(global.unit_check.move_points));
            
            draw_text(150+12,110+14*10,"Can Move &amp; Fire: "+string(global.unit_check.canMoveFire));
            draw_text(150+12,110+14*11,"Can Capture: "+string(global.unit_check.canCapture));
            draw_text(150+12,110+14*12,"Can Attach: "+string(global.unit_check.canAttach));
            draw_text(150+12,110+14*13,"Can Supply: "+string(global.unit_check.canSupply));
            draw_text(150+12,110+14*14,"Can Load infantry: "+string(global.unit_check.canLoadInfantry));
            draw_text(150+12,110+14*15,"Can Hide: "+string(global.unit_check.canHide));
            draw_text(150+12,110+14*16,"Can Disrupt: "+string(global.unit_check.canDisrupt));         
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw stuff
draw_self();
//draw Terrain intel
draw_sprite(miniwin_terrain,miniwin_terrain_ownership,x,y);


//draw Unit intel
if (global.unit_check != 0)
    {
    if (global.unit_check.isObservable)
        {
        // switch to APC load win
        if (global.unit_check.canLoadInfantry and global.unit_check.team = global.P_Turn.team)
            {
            //LR position switch
            if (isLeft) draw_sprite(spr_miniwin_load_L,d_player_index,x,y);
            else draw_sprite(spr_miniwin_load_R,d_player_index,x,y);
            //Draw loaded Units
            if (global.unit_check !=0){
                //draw load A
                if (global.unit_check.load_A != 0)
                    {
                    APC_load_A = global.unit_check.load_A;
                    if isLeft
                        {
                        draw_sprite(APC_load_A.sprite_index,0,x+172, y+12);
                        if  APC_load_A.hp &lt; 0 draw_sprite(spr_unitStats_HP, APC_load_A.hp, x+172, y+12);
                        if  APC_load_A.isCommander draw_sprite(spr_unitStats_Radio, 0, x+172, y+12);
                        if  APC_load_A.max_ammo &gt; 0 and APC_load_A.ammo/APC_load_A.max_ammo &lt; 0.5 and global.blinking draw_sprite(spr_unitStats_ammofuel,2, x+172, y+12);
                        if  APC_load_A.max_fuel &gt; 0 and APC_load_A.fuel/APC_load_A.max_fuel &lt; 0.5 and !global.blinking draw_sprite(spr_unitStats_ammofuel,1, x+172, y+12);                 
                        }
                    else 
                        {
                        draw_sprite(APC_load_A.sprite_index,0,x-28, y+12);
                        if  APC_load_A.hp &lt; 0 draw_sprite(spr_unitStats_HP, APC_load_A.hp, x-28, y+12);
                        if  APC_load_A.isCommander draw_sprite(spr_unitStats_Radio, 0, x-28, y+12);
                        if  APC_load_A.max_ammo &gt; 0 and APC_load_A.ammo/APC_load_A.max_ammo &lt; 0.5 and global.blinking draw_sprite(spr_unitStats_ammofuel,2, x-28, y+12);
                        if  APC_load_A.max_fuel &gt; 0 and APC_load_A.fuel/APC_load_A.max_fuel &lt; 0.5 and !global.blinking draw_sprite(spr_unitStats_ammofuel,1,x-28, y+12);
                        }
                    }
                    
             //Draw Load B       
            if (global.unit_check.load_B != 0)
                {
                APC_load_B = global.unit_check.load_B;
                if isLeft 
                    {
                    draw_sprite(APC_load_B.sprite_index,0,x+172, y+62);
                    if  APC_load_B.hp &lt; 0 draw_sprite(spr_unitStats_HP, APC_load_B.hp, x+172, y+62);
                    if  APC_load_B.isCommander draw_sprite(spr_unitStats_Radio, 0, x+172, y+62);
                    if  APC_load_B.max_ammo &gt; 0 and APC_load_B.ammo/APC_load_B.max_ammo &lt; 0.5 and global.blinking draw_sprite(spr_unitStats_ammofuel,2, x+172, y+62);
                    if  APC_load_B.max_fuel &gt; 0 and APC_load_B.fuel/APC_load_B.max_fuel &lt; 0.5 and !global.blinking draw_sprite(spr_unitStats_ammofuel,1, x+172, y+62);  
                    }
                    else 
                        {
                        draw_sprite(APC_load_B.sprite_index,0,x-28, y+62); 
                        if  APC_load_B.hp &lt; 0 draw_sprite(spr_unitStats_HP, APC_load_B.hp, x-28, y+62);
                        if  APC_load_B.isCommander draw_sprite(spr_unitStats_Radio, 0, x-28, y+62);
                        if  APC_load_B.max_ammo &gt; 0 and APC_load_B.ammo/APC_load_B.max_ammo &lt; 0.5 and global.blinking draw_sprite(spr_unitStats_ammofuel,2, x-28, y+62);
                        if  APC_load_B.max_fuel &gt; 0 and APC_load_B.fuel/APC_load_B.max_fuel &lt; 0.5 and !global.blinking draw_sprite(spr_unitStats_ammofuel,1, x-28, y+62); 
                        }
                    } 
                }
            }
        //draw unit base
        draw_sprite(miniwin_unit,miniwin_unit_ownership,x,y);
        //draw HP
        if (global.unit_check.HP_hidden and global.unit_check.ownership != global.P_Turn.number) draw_sprite(spr_num_light,11,d_hiddenHP_x,d_units_y);
        else scr_draw_num(spr_num_light,false,global.unit_check.hp,d_HP_x,d_units_y,2);
        //draw Fuel
        if(global.unit_check.HP_hidden and global.unit_check.ownership != global.P_Turn.number) scr_draw_num(spr_num_light,false,100000,d_fuel_x,d_units_y,2);
        else scr_draw_num(spr_num_light,false,global.unit_check.fuel,d_fuel_x,d_units_y,3);
        //Draw Ammo
        if( global.unit_check.ammo != -1)
            { 
            if(global.unit_check.HP_hidden and global.unit_check.ownership != global.P_Turn.number) scr_draw_num(spr_num_light,true,100000,d_ammo_x,d_units_y,1);
            else scr_draw_num(spr_num_light,true,global.unit_check.ammo,d_ammo_x,d_units_y,1);
            }
        else draw_sprite(spr_num_light,10,d_ammo_x,d_units_y);
        
        //draw Terrain intel
        draw_sprite(miniwin_terrain,miniwin_terrain_ownership,x,y);
        // draw capture progress
        if( global.unit_check.capturing!= 0)
            {
            scr_draw_num(spr_num_light,false,global.unit_check.capturing,d_cap_x,d_terrain_y,2);
            draw_sprite(spr_miniFlag,global.unit_check.ownership-1,d_flag_x,d_terrain_y)
            }
        }
    }
    
//draw fog
if global.terrain_check.isSmoke{
    draw_sprite_ext(global.terrain_check.draw_smoke_index,global.smoke_frame,x+12,y+60,1,1,0,c_white,global.glow);
    draw_sprite(spr_smoke_outline,global.smoke_frame,x+12,y+60);
    //draw_sprite(spr_smoke_miniwin,global.terrain_check.smoke_left,x+8,y+66);
    }
    


    


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///drqaw temp aux


if aux_on{
    if global.unit_check !=0{
    if global.unit_check.isVisible{ 
        draw_sprite(spr_temp_unit_summary,global.unit_check.unit_index, view_xview[0]+150,view_yview[0]+110);
        draw_sprite(spr_temp_summary_boarder,global.P_Turn.number-1,view_xview[0]+150,view_yview[0]+110);
        }
        }
    draw_sprite(spr_temp_terrain_summary,global.terrain_check.index,view_xview[0]+390,view_yview[0]+110);
    draw_sprite(spr_temp_summary_boarder,global.P_Turn.number-1,view_xview[0]+390,view_yview[0]+110);
    
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
