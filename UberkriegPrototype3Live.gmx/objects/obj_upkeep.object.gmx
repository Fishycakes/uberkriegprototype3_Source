<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_UnitEvent_Repair</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Do Upkeep Stuff

//day change animation

//income added to funds

global.P_Turn.revenue = scr_calc_revenue(global.P_Turn.number)
global.P_Turn.funds += global.P_Turn.revenue;
//reset unit count
global.P_Turn.unit_count = 0;
//calc battle strenth
global.P_Turn.battle_strength = scr_calc_battleStrength(global.P_Turn);

scr_update_upkeep_stats("History",global.P_Turn);

//events stuff
depth = 0;
image_speed = 0;

ds_queue_clear(global.upkeep_q); //just in case
ready_for_next_event = false;
conclude_upkeep = false;
alarm[0] = 1;
processing = 0;

animation_counter = 0;
height_displace = 0;

view_border = 4*24;
view_speed = 8;

//hp repaired by
RepairCostPercent = global.P_Turn.CO.D2D_RepairCosts;
RepairAmmount = global.P_Turn.CO.D2D_Repair;//global.P_Turn.CO.D2D_Repair;


//turn units on if standing
with obj_unit
    {
    isInfiltrate = false; 
    if (ownership = global.P_Turn.number) global.P_Turn.unit_count += 1;
    if isStanding state = "idle";
    if isDisrupted state = "exhaust";
    if (ownership = global.P_Turn.number) 
        {
        if(isHidden)fuel -= 5; show_debug_message("hidden fuel consum");
        fuel += global.P_Turn.CO.D2D_Fuel_R[unit_index];
        if (fuel &gt; max_fuel) fuel = max_fuel;        
        }
    
    if ( obj_map.terrains[ x div 24, y div 24].isProperty )
        {
        if ( obj_map.terrains[ x div 24, y div 24].canRepair_g and obj_map.terrains[ x div 24, y div 24].ownership = global.P_Turn.number and ownership = global.P_Turn.number)
            {
            //repair disrupt
            if (isDisrupted and ownership = global.P_Turn.number) isDisrupted = false; 
            //HP UP
            if( hp &gt;= 10 - other.RepairAmmount and !dummy and hp &lt;10)
                {
                global.P_Turn.funds -= (cost div 10)*(10 -hp)*( other.RepairCostPercent/100);
                hp = 10
                ds_queue_enqueue(global.upkeep_q, obj_map.units[x div 24, y div 24]);
                }
                
            else if ( hp &lt;= 10 -other.RepairAmmount  and !dummy and hp &lt;10)
                {
                hp +=  other.RepairAmmount;
                global.P_Turn.funds -= (cost div 10)* other.RepairAmmount*( other.RepairCostPercent/100);
                ds_queue_enqueue(global.upkeep_q, obj_map.units[x div 24, y div 24]);
                }
                
            fuel = max_fuel;
            ammo = max_ammo;
            }
        }
    }
    
//start upkeep event with heead of Q
if (ds_queue_size(global.upkeep_q) &gt; 0)
    {
    processing = ds_queue_dequeue(global.upkeep_q);
    x = processing.x;
    y = processing.y;
    depth = UI_DEPTH_CURSOR;
    alarm[0] = 1;
    }

else conclude_upkeep = true;

//change cursor position
with obj_battleCursor
    {
    x = global.P_Turn.save_cursor_pos_x;
    y = global.P_Turn.save_cursor_pos_y;
    }
    
    

    
//turn smoke off
with obj_terrain 
    {
    if (isSmoke and smoker = global.P_Turn.number)
        {
        //reduce smoke
        smoke_left -= 1;
        //make smoke go away
            if( smoke_left &lt;= 0 )
            { 
            isSmoke = false;
            smoker = 0;
            if( name != "woods" or object_is_ancestor(self.object_index,obj_property))canHide = false;
            }
        }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    




















</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///set avaliable intel for new turn
//infiltrate must happen each turn for intel
with global.P_Turn
    {
    intel_P[1] = false;
    intel_P[2] = false;
    intel_P[3] = false;
    intel_P[4] = false;
    //turn own intel on
    intel_P[number] = true;
    } 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Uberkrieg ready SFX

//swith_on check sound for when attack
global.P_Turn.CO.Kriegcheck = true;
global.P_Turn.CO.Uberkriegcheck = true;

if (global.P_Turn.CO.charge &gt;= (global.P_Turn.CO.COP_Bar*star_value + global.P_Turn.CO.SCOP_Bar*star_value )and global.P_Turn.CO.SCOP_Bar !=0 ){ 
    audio_play_sound(sfx_UberkriegCharged,1,0);
    global.P_Turn.CO.Kriegcheck = false;
    global.P_Turn.CO.Uberkriegcheck = false;
    }
//kriegskill ready sfx
else if (global.P_Turn.CO.charge &gt;= global.P_Turn.CO.COP_Bar*star_value and global.P_Turn.CO.COP_Bar !=0 ){ 
    audio_play_sound(sfx_KriegSkillCharged,1,0);
    global.P_Turn.CO.Kriegcheck = false;
    global.P_Turn.CO.Uberkriegcheck = false;
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Event actions

if ( conclude_upkeep )

{

    //activate HUD
    
    //check for AI player
    
    if global.isAIplayer[global.P_Turn.number] instance_activate_object(obj_AI_interface);
    else instance_activate_object(obj_battleCursor);
    
    instance_activate_object(obj_miniwin);
    
    //change cursor position
    with obj_battleCursor{
        x = global.P_Turn.save_cursor_pos_x;
        y = global.P_Turn.save_cursor_pos_y;
        }
    
    //change phaze
    global.Phaze = "Main"
    
    //destroy self
    instance_destroy();

}



//move view if unit is out-of-frame



//if not in frame

else if  (    
         ( view_xview[0] + view_wport[0] &lt; processing.x + view_border + 24 and global.canScroll_x ) 
     or  ( view_xview[0] &gt; processing.x - view_border and global.canScroll_x )
     or  ( view_yview[0] &gt; processing.y - view_border and global.canScroll_y ) 
     or  ( view_yview[0] + view_hport[0] &lt; processing.y + view_border+24 and global.canScroll_y )
    )
{ 
    if ( view_xview[0] &gt; processing.x - view_border and global.canScroll_x)
    { 
        
        view_xview[0] -= view_speed;
        alarm[0] = 1;
        
    }


    if ( view_xview[0] + view_wport[0] &lt; processing.x + view_border + 24 and global.canScroll_x) 
    {
        view_xview[0] += view_speed;
        alarm[0] = 1;
    
    }
    
    
    if ( view_yview[0] &gt; processing.y - view_border and global.canScroll_y) 
    {
        
        view_yview[0] -= view_speed;
        alarm[0]  = 1;
        
    }
    
    if ( view_yview[0] + view_hport[0] &lt; processing.y + view_border+24 and global.canScroll_y)
    { 
        view_yview[0] += view_speed;
        alarm[0] = 1;
        
    }
    
}

else if (!ready_for_next_event)
{

    //go to and hold graphic at processing unit position
    
    x = processing.x;
    y = processing.y + height_displace;
    
    if (animation_counter &lt; 7)
    {
    
        height_displace -= 2;
        image_index = animation_counter;
    
    }
    
    if (animation_counter = 10 )
    {
    
        height_displace += 2;
        image_index = 5;
        
    }
    
    
    if (animation_counter = 24)
    {
    
        ready_for_next_event = true;
        height_displace = 0
    
    }
    
    

    
    
    

    
    
    //ready_for_next_event = true;
    
    animation_counter +=1;
    alarm[0] = 1 ;
    

    

}

else if ( ready_for_next_event )
{

    //if next event isn't avaliable
    if ( ds_queue_size(global.upkeep_q) = 0 )
    {
    
        conclude_upkeep = true;
        alarm[0] = 1;
        
    }
    
    else
    {
        
        
         ready_for_next_event = false;
         processing = ds_queue_dequeue(global.upkeep_q);
         
         animation_counter = 0;
         
         //x = processing.x;
         //y = processing.y;    
         alarm[0] = 1;
        

    }




}















</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///debug
/*
draw_text(12,12, string(ds_queue_size(global.upkeep_q)));

if (ds_queue_size(global.upkeep_q) &gt; 0)
draw_text(24,24, string(ds_queue_head(global.upkeep_q).x) + ", " + string(ds_queue_head(global.upkeep_q).y));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
